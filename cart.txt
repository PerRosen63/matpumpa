You're on the right track! Moving the PUT request for updating stock to a later stage (like when the actual order is placed) is a good approach. And yes, the context can be a suitable place to manage your cart data and related operations.

Here's how you can implement adding products to a cart in your context and update the handleAddToCart function:

1. Update AppContext.tsx:

// ... other imports and interfaces ...

interface CartItem {
  product: TopLevel;
  variationId?: number; // If it's a variation, store the variation ID
  quantity: number;
}

interface AppContextProps {
  // ... other props
  cart: CartItem[];
  addToCart: (product: TopLevel, variationId?: number) => void;
  removeFromCart: (productId: number, variationId?: number) => void;
  clearCart: () => void;
}

// ... rest of your AppProvider component

export const AppProvider: React.FC<AppProviderProps> = ({
  // ... your props
}) => {
  // ... your existing state variables ...

  const [cart, setCart] = useState<CartItem[]>([]);

  const addToCart = (product: TopLevel, variationId?: number) => {
    // Check if the item is already in the cart
    const existingCartItemIndex = cart.findIndex(
      (item) => item.product.id === product.id && item.variationId === variationId
    );

    if (existingCartItemIndex !== -1) {
      // If item exists, update quantity
      setCart((prevCart) => {
        const updatedCart = [...prevCart];
        updatedCart[existingCartItemIndex].quantity++;
        return updatedCart;
      });
    } else {
      // If item doesn't exist, add it to the cart
      setCart((prevCart) => [
        ...prevCart,
        { product, variationId, quantity: 1 },
      ]);
    }
  };

  const removeFromCart = (productId: number, variationId?: number) => {
    setCart((prevCart) =>
      prevCart.filter(
        (item) =>
          item.product.id !== productId || item.variationId !== variationId
      )
    );
  };

  const clearCart = () => {
    setCart([]);
  };

  // ... your existing fetchProduct, updateProductStock, updateVariationStock functions ...

  return (
    <AppContext.Provider
      value={{
        // ... other context values
        cart,
        addToCart,
        removeFromCart,
        clearCart,
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

export default AppContext;
2. Update ProductOrderForm.tsx:

import { useContext, useState } from "react";
import AppContext from "../context/AppContext";

export const ProductOrderForm = () => {
  // ... your existing code ...

  const { addToCart } = useContext(AppContext) ?? {
    addToCart: () => {},
  };

  const handleAddToCart = () => {
    if (!selectedProduct) return;

    if (variations.length > 0 && selectedVariationId) {
      addToCart(selectedProduct, selectedVariationId);
    } else {
      addToCart(selectedProduct);
    }
  };

  // ... rest of your ProductOrderForm component ...
};
3. Create/Update ProductCart.tsx:

import { useContext } from "react";
import AppContext from "../context/AppContext";

export const ProductCart = () => {
  const { cart, removeFromCart, clearCart } = useContext(AppContext) ?? {
    cart: [],
    removeFromCart: () => {},
    clearCart: () => {},
  };

  return (
    <>
      <h2>Varukorg</h2>
      <ul>
        {cart.map((item) => (
          <li key={item.product.id + (item.variationId || "")}>
            {item.product.name}
            {item.variationId &&
              ` - ${
                item.product.variations.find((v) => v.id === item.variationId)
                  ?.attributes?.map((attr) => `${attr.option} kg`)
              }`}
            {"  "}
            x {item.quantity}
            <button onClick={() => removeFromCart(item.product.id, item.variationId)}>
              Remove
            </button>
          </li>
        ))}
      </ul>
      <button onClick={clearCart}>Clear Cart</button>
      {/* Add your order submission logic here */}
    </>
  );
};
Explanation:

CartItem Interface: Defines the structure of an item in the cart, including the product, variation ID (if applicable), and quantity.
Cart Management in Context:
cart state: Stores the cart items.
addToCart: Adds a product (and variation, if selected) to the cart, handling quantity updates.
removeFromCart: Removes an item from the cart.
clearCart: Empties the cart.
handleAddToCart Update: Now simply calls the addToCart function from the context.
ProductCart Component: Displays the cart contents, allows removing items, and provides a button to clear the cart. You can add your order submission logic here.
Key Points:

Order Submission: You'll need to implement the logic for submitting the order, which would involve sending the cart data to your server and handling stock updates using the updateProductStock and updateVariationStock functions at that point.
UI Updates: Ensure your UI components (e.g., cart icon, product pages) reflect the changes in the cart.
This setup provides a basic cart functionality managed within your context. You can now expand it with features like quantity updates, order totals, and more.